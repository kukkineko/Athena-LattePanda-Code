"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDeclarationPath = exports.sleep = exports.typesPackageNameToRealName = exports.mustTrimAtTypesPrefix = exports.trimAtTypesPrefixIfPresent = exports.isTypesPackageName = exports.atTypesSlash = exports.mangleScopedPackage = exports.unmangleScopedPackage = exports.isScopedPackage = exports.computeHash = exports.withoutStart = exports.isObject = exports.identity = exports.parseJson = exports.tryParseJson = void 0;
const crypto_1 = __importDefault(require("crypto"));
const minimatch_1 = require("minimatch");
function tryParseJson(text, predicate) {
    try {
        return parseJson(text, predicate);
    }
    catch {
        return undefined;
    }
}
exports.tryParseJson = tryParseJson;
function parseJson(text, predicate = (_) => true) {
    let parsed;
    try {
        parsed = JSON.parse(text);
    }
    catch (err) {
        throw new Error(`${err.message} due to JSON: ${text}`);
    }
    if (!predicate(parsed)) {
        throw new Error("Parsed JSON did not match required form");
    }
    return parsed;
}
exports.parseJson = parseJson;
function identity(t) {
    return t;
}
exports.identity = identity;
function isObject(value) {
    return !!value && typeof value === "object";
}
exports.isObject = isObject;
function withoutStart(s, start) {
    return s.startsWith(start) ? s.slice(start.length) : undefined;
}
exports.withoutStart = withoutStart;
function computeHash(content) {
    // Normalize line endings
    const normalContent = content.replace(/\r\n?/g, "\n");
    const h = crypto_1.default.createHash("sha256");
    h.update(normalContent, "utf8");
    return h.digest("hex");
}
exports.computeHash = computeHash;
function isScopedPackage(packageName) {
    return packageName.startsWith("@");
}
exports.isScopedPackage = isScopedPackage;
// Based on `getPackageNameFromAtTypesDirectory` in TypeScript.
function unmangleScopedPackage(packageName) {
    const separator = "__";
    return packageName.includes(separator) ? `@${packageName.replace(separator, "/")}` : undefined;
}
exports.unmangleScopedPackage = unmangleScopedPackage;
// Reverts unmangleScopedPackage.
function mangleScopedPackage(packageName) {
    return isScopedPackage(packageName) ? packageName.replace(/\//, "__").replace("@", "") : packageName;
}
exports.mangleScopedPackage = mangleScopedPackage;
exports.atTypesSlash = "@types/";
function isTypesPackageName(packageName) {
    return packageName.startsWith(exports.atTypesSlash);
}
exports.isTypesPackageName = isTypesPackageName;
function trimAtTypesPrefix(packageName) {
    return packageName.slice(exports.atTypesSlash.length);
}
function trimAtTypesPrefixIfPresent(packageName) {
    if (isTypesPackageName(packageName)) {
        return trimAtTypesPrefix(packageName);
    }
    return packageName;
}
exports.trimAtTypesPrefixIfPresent = trimAtTypesPrefixIfPresent;
function mustTrimAtTypesPrefix(packageName) {
    if (!isTypesPackageName(packageName)) {
        throw new Error(`Not a types package name: ${packageName}`);
    }
    return trimAtTypesPrefix(packageName);
}
exports.mustTrimAtTypesPrefix = mustTrimAtTypesPrefix;
function typesPackageNameToRealName(typesPackageName) {
    var _a;
    const name = mustTrimAtTypesPrefix(typesPackageName);
    return (_a = unmangleScopedPackage(name)) !== null && _a !== void 0 ? _a : name;
}
exports.typesPackageNameToRealName = typesPackageNameToRealName;
async function sleep(seconds) {
    return new Promise((resolve) => setTimeout(resolve, seconds * 1000));
}
exports.sleep = sleep;
const declarationMatcher = new minimatch_1.Minimatch("**/*.d.{ts,cts,mts,*.ts}", { optimizationLevel: 2 });
function isDeclarationPath(path) {
    if (process.platform === "win32") {
        path = path.replace(/\\/g, "/");
    }
    return declarationMatcher.match(path);
}
exports.isDeclarationPath = isDeclarationPath;
//# sourceMappingURL=miscellany.js.map